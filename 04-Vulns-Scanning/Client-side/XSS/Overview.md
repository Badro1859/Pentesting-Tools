# Cross-site scripting XSS

Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to compromise the interactions that users have with a vulnerable application.

## How does XSS work?

Cross-site scripting works by manipulating a vulnerable web site so that it returns malicious JavaScript to users. When the malicious code executes inside a victim's browser, the attacker can fully compromise their interaction with the application.

## XSS proof of concept

- use the `alert()` function for this purpose because it's short, harmless, and pretty hard to miss when it's successfully called. 

- use an alternative PoC payload. In this scenario, we recommend the `print()` function.

## Types of XSS attacks

There are three main types of XSS attacks. These are:

- Reflected XSS, where the malicious script comes from the current HTTP request.
- Stored XSS, where the malicious script comes from the website's database.
- DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

### Testing Reflected XSS

1. Test every entry point.
2. Submit random alphanumeric values.
3. Determine the reflection context.
4. Test a candidate payload.
5. Test alternative payloads.
6. Test the attack in a browser.

### Testing Stored XSS

1. You need to test all relevant "entry points" via which attacker-controllable data can enter the application's processing, and all "exit points" at which that data might appear in the application's responses.

- Entry points:
  - Parameters or other data within the URL query string and message body.
  - The URL file path.
  - HTTP request headers that might not be exploitable in relation to reflected XSS.
  - Any out-of-band routes via which an attacker can deliver data into the application.

- Exit points:
  - Data submitted to any entry point could in principle be emitted from any exit point.
  - Data that is currently stored by the application is often vulnerable to being overwritten due to other actions performed within the application.

### Testing DOM-based XSS

To deliver a DOM-based XSS attack, you need to place data into a `source` so that it is propagated to a `sink` and causes execution of arbitrary JavaScript.

- sink: supports dynamic code execution, such as eval() or innerHTML.
- source: The most common source for DOM XSS is the URL, other source is inputs, JSvariables...

#### Testing HTML sinks

To test for DOM XSS in an HTML sink, place a random alphanumeric string into the source (such as location.search), then use developer tools to inspect the HTML and find where your string appears.

#### Testing JavaScript execution sinks

Testing JavaScript execution sinks for DOM-based XSS is a little harder. With these sinks, your input doesn't necessarily appear anywhere within the DOM, so you can't search for it. Instead you'll need to use the JavaScript debugger to determine whether and how your input is sent to a sink.

#### Testing using DOM Invader

Identifying and exploiting DOM XSS in the wild can be a tedious process, often requiring you to manually trawl through complex, minified JavaScript. If you use Burp's browser, however, you can take advantage of its built-in DOM Invader extension, which does a lot of the hard work for you.
show: <https://portswigger.net/burp/documentation/desktop/tools/dom-invader>

#### Sources and sinks in third-party dependencies

##### DOM XSS in jQuery

- jQuery's attr() function can change the attributes of DOM elements. --> you can add : 
`('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));`

exploit: location.search= `?returnUrl=javascript:alert(document.domain)`

- jQuery's `$()` selector function, which can be used to inject malicious objects into the DOM.

exploit: `<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">`

##### DOM XSS in AngularJS

If a framework like AngularJS is used, it may be possible to execute JavaScript without angle brackets or events. When a site uses the `ng-app` attribute on an HTML element, it will be processed by AngularJS. In this case, AngularJS will execute JavaScript inside double curly braces that can occur directly in HTML or inside attributes.

exploit : `{{$on.constructor('alert(1)')()}}`

#### Reflected DOM XSS

In a reflected DOM XSS vulnerability, the server processes data from the request, and echoes the data into the response. The reflected data might be placed into a JavaScript string literal, or a data item within the DOM, such as a form field. A script on the page then processes the reflected data in an unsafe way, ultimately writing it to a dangerous sink.

#### Sinks can lead to DOM-XSS vulnerabilities

document.write()
document.writeln()
document.domain
element.innerHTML
element.outerHTML
element.insertAdjacentHTML
element.onevent

for jQuery functions:
add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()
